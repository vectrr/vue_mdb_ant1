"use strict";
/*
 Copyright(c) 2013-2015, 2020 3NSoft Inc.
 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
 file, you can obtain one at http://mozilla.org/MPL/2.0/.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeArrayForOutput = exports.wipe = exports.makeFactory = void 0;
/**
 * This module provide an object pool for typed arrays used in the library.
 * When we turn off reusing, by always making new arrays, time for boxes goes up
 * dramatically (due to arrays needed in stream?).
 */
class NumericArrPool {
    constructor(arrFactory) {
        this.arrFactory = arrFactory;
        this.pool = new Array(16);
        this.poolIndex = -1;
        this.wipedIndex = -1;
        Object.seal(this);
    }
    static makeUint8ArrayPool(numOfElemsInObj) {
        return new NumericArrPool(() => new Uint8Array(numOfElemsInObj));
    }
    static makeUint32ArrayPool(numOfElemsInObj) {
        return new NumericArrPool(() => new Uint32Array(numOfElemsInObj));
    }
    /**
     * This either creates new, or gets a spare array from the pool.
     * Newly created array is not put into pool, because it is given to someone
     * for use.
     * If someone forgets to return it, there shall be no leaking references.
     * @returns TypedArray, created by set arrFactory, with set number of
     * elements in it.
     * Note that array may and shall have arbitrary data in it, thus, any
     * initialization must be performed explicitly.
     */
    get() {
        let arr;
        if (this.poolIndex < 0) {
            arr = this.arrFactory();
        }
        else {
            const pooledArr = this.pool[this.poolIndex];
            if (!pooledArr) {
                throw new Error(`Null juggling failed`);
            }
            arr = pooledArr;
            this.pool[this.poolIndex] = null;
            this.poolIndex -= 1;
            if (this.poolIndex < this.wipedIndex) {
                this.wipedIndex = this.poolIndex;
            }
        }
        return arr;
    }
    /**
     * This puts array into the pool, but it does not touch a content of array.
     * @param arr
     */
    recycle(arr) {
        this.poolIndex += 1;
        this.pool[this.poolIndex] = arr;
    }
    /**
     * This wipes all arrays in this pool.
     */
    wipe() {
        for (let i = (this.wipedIndex + 1); i <= this.poolIndex; i += 1) {
            let uintArr = this.pool[i];
            if (uintArr) {
                for (let j = 0; j < uintArr.length; j += 1) {
                    uintArr[j] = 0;
                }
            }
        }
        this.wipedIndex = this.poolIndex;
    }
}
function makeFactory() {
    const f = new ArrFactory();
    return {
        getUint8Array: f.getUint8Array.bind(f),
        getUint32Array: f.getUint32Array.bind(f),
        recycle: f.recycle.bind(f),
        wipeRecycled: f.wipeRecycled.bind(f),
        clear: f.clear.bind(f),
        wipe: wipe
    };
}
exports.makeFactory = makeFactory;
class ArrFactory {
    constructor() {
        this.uint8s = {};
        this.uint32s = {};
        this.wipe = wipe;
        Object.freeze(this);
    }
    getUint8Array(len) {
        const pool = this.uint8s[len];
        return (pool ? pool.get() : new Uint8Array(len));
    }
    getUint32Array(len) {
        const pool = this.uint32s[len];
        return (pool ? pool.get() : new Uint32Array(len));
    }
    recycleUint8Array(arr) {
        let pool = this.uint8s[arr.length];
        if (!pool) {
            pool = NumericArrPool.makeUint8ArrayPool(arr.length);
            this.uint8s[arr.length] = pool;
        }
        pool.recycle(arr);
    }
    recycleUint32Array(arr) {
        let pool = this.uint32s[arr.length];
        if (!pool) {
            pool = NumericArrPool.makeUint32ArrayPool(arr.length);
            this.uint32s[arr.length] = pool;
        }
        pool.recycle(arr);
    }
    recycle(...arrays) {
        for (const arr of arrays) {
            if (!arr)
                continue;
            if ((arr.byteOffset !== 0)
                || (arr.length * arr.BYTES_PER_ELEMENT !== arr.buffer.byteLength)) {
                throw new TypeError("One of given arguments is a view " +
                    "of an array, and these are not supposed to be recycled.");
            }
            if (arr instanceof Uint8Array) {
                this.recycleUint8Array(arr);
            }
            else if (arr instanceof Uint32Array) {
                this.recycleUint32Array(arr);
            }
            else {
                throw new TypeError("This works with typed arrays that have 1 or 4 bytes " +
                    "per element, but array claims to have " +
                    arr.BYTES_PER_ELEMENT);
            }
        }
    }
    wipeRecycled() {
        for (const len in this.uint8s) {
            this.uint8s[len].wipe();
        }
        for (const len in this.uint32s) {
            this.uint32s[len].wipe();
        }
    }
    clear() {
        for (const len in this.uint8s) {
            delete this.uint8s[len];
        }
        for (const len in this.uint32s) {
            delete this.uint32s[len];
        }
    }
}
Object.freeze(ArrFactory);
Object.freeze(ArrFactory.prototype);
/**
 * This zeros all elements of given arrays, or given array views.
 * Use this function on things that needs secure cleanup, but should not be
 * recycled due to their odd and/or huge size, as it makes pooling inefficient.
 */
function wipe(...arrays) {
    for (const arr of arrays) {
        if (!arr)
            continue;
        try {
            for (let j = 0; j < arr.length; j += 1) {
                arr[j] = 0;
            }
        }
        catch (e) { }
    }
}
exports.wipe = wipe;
exports.makeArrayForOutput = ((Buffer && (typeof Buffer.alloc === 'function')) ?
    len => Buffer.alloc(len) : len => new Uint8Array(len));
Object.freeze(exports);
